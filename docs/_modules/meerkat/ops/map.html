
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>meerkat.ops.map &#8212; ðŸ”® v0.2.6a14</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../_static/meerkat_logo.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"><div class='topnav'></div></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/meerkat_banner_padded.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">ðŸ”® v0.2.6a14</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../index.html">
                    Welcome to Meerkat ðŸ”®
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../start/install.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../start/quickstart-df.html">
   Quickstart: Data Frames
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../start/quickstart-interactive.html">
   Quickstart: Interactive Apps
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../start/tutorials/index.html">
   Tutorials
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-0.html">
     Tutorial 0: Data Frames for Unstructured Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-1.html">
     Tutorial 1: Image Gallery
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-2.html">
     Tutorial 2: Reactive Image Viewer
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-3.html">
     Tutorial 3: Query a Large Language Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-4.html">
     Tutorial 4: Search Engine over a Dataset
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-filter-sort.html">
     Tutorial: Filter &amp; Sort
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-simple-counter.html">
     Tutorial: A Simple Counter
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../start/tutorials/tutorial-simple-dataframe-viewer.html">
     A Simple DataFrame Viewer
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  User Guide
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../user-guide/overview.html">
   Overview
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../user-guide/dataframe/index.html">
   DataFrame
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/dataframe/selection.html">
     Data Selection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/dataframe/column/index.html">
     Column
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../user-guide/dataframe/ops/index.html">
     Operations
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/dataframe/ops/mapping.html">
       Mapping:
       <code class="docutils literal notranslate">
        <span class="pre">
         map
        </span>
       </code>
       and
       <code class="docutils literal notranslate">
        <span class="pre">
         defer
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/dataframe/ops/combining.html">
       Combining:
       <code class="docutils literal notranslate">
        <span class="pre">
         concat
        </span>
       </code>
       and
       <code class="docutils literal notranslate">
        <span class="pre">
         merge
        </span>
       </code>
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/dataframe/ops/grouping.html">
       Grouping:
       <code class="docutils literal notranslate">
        <span class="pre">
         groupby
        </span>
       </code>
       and
       <code class="docutils literal notranslate">
        <span class="pre">
         clusterby
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/dataframe/io.html">
     I/O
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../user-guide/dataframe/advanced/index.html">
     Advanced
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/dataframe/advanced/copying.html">
       Copy vs. View Behavior
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/dataframe/advanced/blocks.html">
       Blocks and the BlockManager
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../user-guide/interactive/index.html">
   Interactive
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/running-meerkat-interfaces.html">
     Running Meerkat Interfaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/reactive-functions/index.html">
     Reactive Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/stores/index.html">
     Stores
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/components/index.html">
     Components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/endpoints/index.html">
     Endpoints
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../user-guide/interactive/formatters/index.html">
     Formatters
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../../user-guide/interactive/advanced/index.html">
     Advanced
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/interactive/advanced/sharing.html">
       Sharing
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../../user-guide/interactive/advanced/under-the-hood.html">
       Under the Hood
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../user-guide/cheat-sheet.html">
   Cheat Sheet
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../advanced/magic-contexts/index.html">
   Magic Contexts
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../advanced/magic-contexts/limitations.html">
     Limitations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../advanced/configuring.html">
   Configuring Meerkat
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Ecosystem
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../datasets/index.html">
   Datasets
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../datasets/contributing-datasets.html">
     Contributing Datasets
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Examples
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../examples/index.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../examples/meerkat-in-5-minutes.html">
     Meerkat in 5 Minutes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../examples/image-search.html">
     Building image search
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  API Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../../apidocs/index.html">
   API Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../apidocs/dataframe.html">
     DataFrame
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../apidocs/columns.html">
     Columns
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../apidocs/interactive.html">
     Interactive
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../../apidocs/ops.html">
     Operations
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/hazyresearch/meerkat/"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/hazyresearch/meerkat//issues/new?title=Issue%20on%20page%20%2F_modules/meerkat/ops/map.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for meerkat.ops.map</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">meerkat.tools.docs</span> <span class="k">as</span> <span class="nn">docs</span>
<span class="kn">from</span> <span class="nn">meerkat.block.abstract</span> <span class="kn">import</span> <span class="n">BlockView</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">meerkat.columns.abstract</span> <span class="kn">import</span> <span class="n">Column</span>
    <span class="kn">from</span> <span class="nn">meerkat.columns.deferred.base</span> <span class="kn">import</span> <span class="n">DeferredColumn</span>
    <span class="kn">from</span> <span class="nn">meerkat.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>


<span class="n">_SHARED_DOCS_</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;input_description&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">DescriptionSection</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *What gets passed to function?*</span>

<span class="sd">    *   If ${data} is a :class:`DataFrame` and ``outputs`` is not passed, then the \</span>
<span class="sd">        function&#39;s signature is inspected to determine which columns to pass as \</span>
<span class="sd">        keyword arguments to the function.</span>
<span class="sd">        For example, if the function is</span>
<span class="sd">        ``lambda age, residence: age &gt; 18 and residence == &quot;NY&quot;``, then</span>
<span class="sd">        the columns ``age`` and ``residence`` will be passed to the function. If the</span>
<span class="sd">        columns are not present in the DataFrame, then a `ValueError` will be raised.</span>
<span class="sd">    *   If ${data} is a :class:`DataFrame` and ``outputs`` is  ``&quot;single&quot;``, then \</span>
<span class="sd">        mapping between columns and function arguments can be overridden by passing</span>
<span class="sd">        a the ``inputs`` argument.</span>
<span class="sd">    *   If ${data} is a :class:`Column` then values of the</span>
<span class="sd">        column are passed as a single positional argument to the function. The</span>
<span class="sd">        ``inputs`` argument is ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        function (Callable): The function that will be applied to the rows of</span>
<span class="sd">            ``${data}``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;is_batched_fn&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        is_batched_fn (bool, optional): Whether the function must be applied on a</span>
<span class="sd">            batch of rows. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;batch_size&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        batch_size (int, optional): The size of the batch. Defaults to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inputs (Dict[str, str], optional): Dictionary mapping column names in</span>
<span class="sd">            ``${data}`` to keyword arguments of ``function``. Ignored if ``${data}`` is</span>
<span class="sd">            a column. When calling ``function`` values from the columns will be fed to</span>
<span class="sd">            the corresponding keyword arguments. Defaults to None, in which case it</span>
<span class="sd">            inspects the signature of the function. It then finds the columns with the</span>
<span class="sd">            same names in the DataFrame and passes the corresponding values to the</span>
<span class="sd">            function. If the function takes a non-default argument that is not a</span>
<span class="sd">            column in the DataFrame, the operation will raise a `ValueError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;outputs&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        outputs (Union[Dict[any, str], Tuple[str]], optional): Controls how the output</span>
<span class="sd">            of ``function`` is mapped to the output of :func:`${name}`.</span>
<span class="sd">            Defaults to ``None``.</span>

<span class="sd">            *   If ``None``: the output is inferred from the return type of the</span>
<span class="sd">                function. See explanation above.</span>
<span class="sd">            *   If ``&quot;single&quot;``: a single :class:`DeferredColumn` is returned.</span>
<span class="sd">            *   If a ``Dict[any, str]``: then a :class:`DataFrame` containing</span>
<span class="sd">                DeferredColumns is returned. This is useful when the output of</span>
<span class="sd">                ``function`` is a ``Dict``. ``outputs`` maps the outputs of ``function``</span>
<span class="sd">                to column names in the resulting :class:`DataFrame`.</span>
<span class="sd">            *   If a ``Tuple[str]``: then a :class:`DataFrame` containing</span>
<span class="sd">                output :class:`DeferredColumn` is returned. This is useful when the</span>
<span class="sd">                of ``function`` is a ``Tuple``. ``outputs`` maps the outputs of</span>
<span class="sd">                ``function`` to column names in the resulting :class:`DataFrame`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;output_type&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        output_type (Union[Dict[str, type], type], optional): Coerce the column.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;materialize&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        materialize (bool, optional): Whether to materialize the input column(s).</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;use_ray&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        use_ray (bool): Use Ray to parallelize the computation. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;num_blocks&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        num_blocks (int): When using Ray, the number of blocks to split the data into. </span>
<span class="sd">            Defaults to 100.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;blocks_per_window&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        blocks_per_window (int): When using Ray, the number of blocks to process in a</span>
<span class="sd">            single Ray task. Defaults to 10.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;pbar&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="o">.</span><span class="n">Arg</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pbar (bool): Show a progress bar. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>     
    <span class="p">),</span>
<span class="p">}</span>


<div class="viewcode-block" id="defer"><a class="viewcode-back" href="../../../apidocs/dataframe.html#meerkat.defer">[docs]</a><span class="nd">@docs</span><span class="o">.</span><span class="n">doc</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">_SHARED_DOCS_</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;defer&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">defer</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;Column&quot;</span><span class="p">],</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">is_batched_fn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">any</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;Column&quot;</span><span class="p">]],</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;Column&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">materialize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;DeferredColumn&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create one or more DeferredColumns that lazily applies a function to</span>
<span class="sd">    each row in ${data}.</span>

<span class="sd">    This function shares nearly the exact same signature</span>
<span class="sd">    with :func:`map`, the difference is that :func:`~meerkat.defer` returns a column</span>
<span class="sd">    that has not yet been computed. It is a placeholder for a column that will be</span>
<span class="sd">    computed later.</span>

<span class="sd">    Learn more in the user guide: :ref:`guide/dataframe/ops/mapping/deferred`.</span>

<span class="sd">    {input_description}</span>

<span class="sd">    *What gets returned by defer?*</span>

<span class="sd">    *   If ``function`` returns a single value, then ``defer``</span>
<span class="sd">        will return a :class:`DeferredColumn` object.</span>

<span class="sd">    *   If ``function`` returns a dictionary, then ``defer`` will return a</span>
<span class="sd">        :class:`DataFrame` containing :class:`DeferredColumn` objects. The keys of the</span>
<span class="sd">        dictionary are used as column names. The ``outputs`` argument can be used to</span>
<span class="sd">        override the column names.</span>

<span class="sd">    *   If ``function`` returns a tuple, then ``defer`` will return a :class:`DataFrame`</span>
<span class="sd">        containing :class:`DeferredColumn` objects. The column names will be integers.</span>
<span class="sd">        The column names can be overriden by passing a tuple to the ``outputs``</span>
<span class="sd">        argument.</span>

<span class="sd">    *   If ``function`` returns a tuple or a dictionary, then passing ``&quot;single&quot;`` to</span>
<span class="sd">        the ``outputs`` argument will cause ``defer`` to return a single</span>
<span class="sd">        :class:`DeferredColumn` that materializes to a :class:`ObjectColumn`.</span>

<span class="sd">    *How do you execute the deferred map?*</span>

<span class="sd">    Depending on ``function`` and the ``outputs`` argument, returns either a</span>
<span class="sd">    :class:`DeferredColumn` or a :class:`DataFrame`. Both are **callables**. To execute</span>
<span class="sd">    the deferred map, simply call the returned object.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is also available as a method of :class:`DataFrame` and</span>
<span class="sd">        :class:`Column` under the name ``defer``.</span>


<span class="sd">    Args:</span>
<span class="sd">        ${data} (DataFrame): The :class:`DataFrame` or :class:`Column` to which the</span>
<span class="sd">            function will be applied.</span>
<span class="sd">        ${function}</span>
<span class="sd">        ${is_batched_fn}</span>
<span class="sd">        ${batch_size}</span>
<span class="sd">        ${inputs}</span>
<span class="sd">        ${outputs}</span>
<span class="sd">        ${output_type}</span>
<span class="sd">        ${materialize}</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[DataFrame, DeferredColumn]: A :class:`DeferredColumn` or a</span>
<span class="sd">            :class:`DataFrame` containing :class:`DeferredColumn` representing the</span>
<span class="sd">            deferred map.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>
<span class="sd">    We start with a small DataFrame of voters with two columns: `birth_year`, which</span>
<span class="sd">    contains the birth year of each person, and `residence`, which contains the state in</span>
<span class="sd">    which each person lives.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        import datetime</span>
<span class="sd">        import meerkat as mk</span>

<span class="sd">        df = mk.DataFrame({</span>
<span class="sd">            &quot;birth_year&quot;: [1967, 1993, 2010, 1985, 2007, 1990, 1943],</span>
<span class="sd">            &quot;residence&quot;: [&quot;MA&quot;, &quot;LA&quot;, &quot;NY&quot;, &quot;NY&quot;, &quot;MA&quot;, &quot;MA&quot;, &quot;LA&quot;]</span>
<span class="sd">        })</span>


<span class="sd">    **Single input column.** Lazily create a column of birth years to a column of ages.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        df[&quot;age&quot;] = df[&quot;birth_year&quot;].defer(</span>
<span class="sd">            lambda x: datetime.datetime.now().year - x</span>
<span class="sd">        )</span>
<span class="sd">        df[&quot;age&quot;]</span>

<span class="sd">    We can materialize the deferred map (*i.e.* run it) by calling the column.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        df[&quot;age&quot;]()</span>


<span class="sd">    **Multiple input columns.** Lazily create a column of birth years to a column of</span>
<span class="sd">    ages.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        df[&quot;ma_eligible&quot;] = df.defer(</span>
<span class="sd">            lambda age, residence: (residence == &quot;MA&quot;) and (age &gt;= 18)</span>
<span class="sd">        )</span>
<span class="sd">        df[&quot;ma_eligible&quot;]()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">meerkat</span> <span class="kn">import</span> <span class="n">DeferredColumn</span>
    <span class="kn">from</span> <span class="nn">meerkat.block.deferred_block</span> <span class="kn">import</span> <span class="n">DeferredBlock</span><span class="p">,</span> <span class="n">DeferredOp</span>
    <span class="kn">from</span> <span class="nn">meerkat.columns.abstract</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">infer_column_type</span>
    <span class="kn">from</span> <span class="nn">meerkat.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>

    <span class="n">base_function</span> <span class="o">=</span> <span class="n">function</span>
    <span class="c1"># prepare arguments for LambdaOp</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">kw</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="c1"># TODO: make this work with a list</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># infer mapping from function signature if possible otherwise pass full row</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Non-default argument &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; does not have a corresponding &quot;</span>
                        <span class="s2">&quot;column in the DataFrame. If your function expects a full &quot;</span>
                        <span class="s2">&quot;DataFrame row, pass ``inputs=&#39;row&#39;`` to ``map``. Otherwise, &quot;</span>
                        <span class="s2">&quot;please provide an `inputs` mapping &quot;</span>
                        <span class="s2">&quot;or pass a lambda function with a different signature. &quot;</span>
                        <span class="s2">&quot;See map documentation for more details.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">inputs</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">inputs</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">col_name</span><span class="p">:</span> <span class="n">col</span> <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># FIXME: this should use data._clone instead!</span>
                <span class="k">if</span> <span class="n">is_batched_fn</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">base_function</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">function</span> <span class="o">=</span> <span class="n">wrapper</span>

        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;``inputs`` must be Mapping, Sequence or &#39;row&#39;&quot;</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">DeferredOp</span><span class="p">(</span>
        <span class="n">fn</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="n">is_batched_fn</span><span class="o">=</span><span class="n">is_batched_fn</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">return_format</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">materialize_inputs</span><span class="o">=</span><span class="n">materialize</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">block</span> <span class="o">=</span> <span class="n">DeferredBlock</span><span class="o">.</span><span class="n">from_block_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">op</span><span class="p">)</span>

    <span class="n">first_row</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_row</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
        <span class="c1"># support for splitting a dict into multiple columns without specifying outputs</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">output_key</span><span class="p">:</span> <span class="n">output_key</span> <span class="k">for</span> <span class="n">output_key</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">}</span>
        <span class="n">op</span><span class="o">.</span><span class="n">return_format</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_row</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
        <span class="c1"># support for splitting a tuple into multiple columns without specifying outputs</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">))])</span>
        <span class="n">op</span><span class="o">.</span><span class="n">return_format</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">outputs</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
        <span class="c1"># can only infer output type if the the input columns are nonempty</span>
        <span class="k">if</span> <span class="n">output_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="n">infer_column_type</span><span class="p">([</span><span class="n">first_row</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_type</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must provide a single `output_type` if `outputs` is None.&quot;</span>
            <span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">DeferredColumn</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">BlockView</span><span class="p">(</span><span class="n">block_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span> <span class="n">output_type</span><span class="o">=</span><span class="n">output_type</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">col</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">output_key</span><span class="p">]:</span> <span class="n">infer_column_type</span><span class="p">([</span><span class="n">col</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">first_row</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_type</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must provide a `output_type` mapping if `outputs` is a mapping.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">col</span><span class="p">:</span> <span class="n">DeferredColumn</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">BlockView</span><span class="p">(</span><span class="n">block_index</span><span class="o">=</span><span class="n">output_key</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
                    <span class="n">output_type</span><span class="o">=</span><span class="n">output_type</span><span class="p">[</span><span class="n">outputs</span><span class="p">[</span><span class="n">output_key</span><span class="p">]],</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_type</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must provide a `output_type` sequence if `outputs` is a sequence.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">col</span><span class="p">:</span> <span class="n">DeferredColumn</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">BlockView</span><span class="p">(</span><span class="n">block_index</span><span class="o">=</span><span class="n">output_key</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">),</span>
                    <span class="n">output_type</span><span class="o">=</span><span class="n">output_type</span><span class="p">[</span><span class="n">output_key</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="map"><a class="viewcode-back" href="../../../apidocs/dataframe.html#meerkat.map">[docs]</a><span class="nd">@docs</span><span class="o">.</span><span class="n">doc</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">_SHARED_DOCS_</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;defer&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;Column&quot;</span><span class="p">],</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">is_batched_fn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">any</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;Column&quot;</span><span class="p">]],</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;Column&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">materialize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_ray</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">num_blocks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">blocks_per_window</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new :class:`Column` or :class:`DataFrame` by applying a</span>
<span class="sd">    function to each row in ${data}.</span>

<span class="sd">    This function shares nearly the exact same signature</span>
<span class="sd">    with :func:`defer`, the difference is that :func:`~meerkat.defer` returns a column</span>
<span class="sd">    that has not yet been computed. It is a placeholder for a column that will be</span>
<span class="sd">    computed later.</span>

<span class="sd">    Learn more in the user guide: :ref:`guide/dataframe/ops/mapping`.</span>

<span class="sd">    {input_description}</span>

<span class="sd">    *What gets returned by defer?*</span>

<span class="sd">    *   If ``function`` returns a single value, then ``defer``</span>
<span class="sd">        will return a :class:`DeferredColumn` object.</span>

<span class="sd">    *   If ``function`` returns a dictionary, then ``defer`` will return a</span>
<span class="sd">        :class:`DataFrame` containing :class:`DeferredColumn` objects. The keys of the</span>
<span class="sd">        dictionary are used as column names. The ``outputs`` argument can be used to</span>
<span class="sd">        override the column names.</span>

<span class="sd">    *   If ``function`` returns a tuple, then ``defer`` will return a :class:`DataFrame`</span>
<span class="sd">        containing :class:`DeferredColumn` objects. The column names will be integers.</span>
<span class="sd">        The column names can be overriden by passing a tuple to the ``outputs``</span>
<span class="sd">        argument.</span>

<span class="sd">    *   If ``function`` returns a tuple or a dictionary, then passing ``&quot;single&quot;`` to</span>
<span class="sd">        the ``outputs`` argument will cause ``defer`` to return a single</span>
<span class="sd">        :class:`DeferredColumn` that materializes to a :class:`ObjectColumn`</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is also available as a method of :class:`DataFrame` and</span>
<span class="sd">        :class:`Column` under the name ``map``.</span>


<span class="sd">    Args:</span>
<span class="sd">        ${data} (DataFrame): The :class:`DataFrame` or :class:`Column` to which the</span>
<span class="sd">            function will be applied.</span>
<span class="sd">        ${function}</span>
<span class="sd">        ${is_batched_fn}</span>
<span class="sd">        ${batch_size}</span>
<span class="sd">        ${inputs}</span>
<span class="sd">        ${outputs}</span>
<span class="sd">        ${output_type}</span>
<span class="sd">        ${materialize}</span>
<span class="sd">        use_ray (bool): Use Ray to parallelize the computation. Defaults to False.</span>
<span class="sd">        num_blocks (int): When using Ray, the number of blocks to split the data</span>
<span class="sd">            into. Defaults to 100.</span>
<span class="sd">        blocks_per_window (int): When using Ray, the number of blocks to process</span>
<span class="sd">            in a single Ray task. Defaults to 10.</span>
<span class="sd">        pbar (bool): Show a progress bar. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[DataFrame, Column]: A :class:`Column` or a :class:`DataFrame`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>
<span class="sd">    We start with a small DataFrame of voters with two columns: `birth_year`, which</span>
<span class="sd">    contains the birth year of each person, and `residence`, which contains the state in</span>
<span class="sd">    which each person lives.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        import datetime</span>
<span class="sd">        import meerkat as mk</span>

<span class="sd">        df = mk.DataFrame({</span>
<span class="sd">            &quot;birth_year&quot;: [1967, 1993, 2010, 1985, 2007, 1990, 1943],</span>
<span class="sd">            &quot;residence&quot;: [&quot;MA&quot;, &quot;LA&quot;, &quot;NY&quot;, &quot;NY&quot;, &quot;MA&quot;, &quot;MA&quot;, &quot;LA&quot;]</span>
<span class="sd">        })</span>


<span class="sd">    **Single input column.** Lazily create a column of birth years to a column of ages.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        df[&quot;age&quot;] = df[&quot;birth_year&quot;].map(</span>
<span class="sd">            lambda x: datetime.datetime.now().year - x</span>
<span class="sd">        )</span>
<span class="sd">        df[&quot;age&quot;]</span>


<span class="sd">    **Multiple input columns.** Lazily create a column of birth years to a column of</span>
<span class="sd">    ages.</span>

<span class="sd">    .. ipython:: python</span>

<span class="sd">        df[&quot;ma_eligible&quot;] = df.map(</span>
<span class="sd">            lambda age, residence: (residence == &quot;MA&quot;) and (age &gt;= 18)</span>
<span class="sd">        )</span>
<span class="sd">        df[&quot;ma_eligible&quot;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">deferred</span> <span class="o">=</span> <span class="n">defer</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
        <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">,</span>
        <span class="n">is_batched_fn</span><span class="o">=</span><span class="n">is_batched_fn</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
        <span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">,</span>
        <span class="n">output_type</span><span class="o">=</span><span class="n">output_type</span><span class="p">,</span>
        <span class="n">materialize</span><span class="o">=</span><span class="n">materialize</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_materialize</span><span class="p">(</span>
        <span class="n">deferred</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
        <span class="n">use_ray</span><span class="o">=</span><span class="n">use_ray</span><span class="p">,</span>
        <span class="n">num_blocks</span><span class="o">=</span><span class="n">num_blocks</span><span class="p">,</span>
        <span class="n">blocks_per_window</span><span class="o">=</span><span class="n">blocks_per_window</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_materialize</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;Column&quot;</span><span class="p">],</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">use_ray</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">num_blocks</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">blocks_per_window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
    <span class="kn">import</span> <span class="nn">logging</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
    <span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
    <span class="kn">import</span> <span class="nn">torch</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

    <span class="kn">import</span> <span class="nn">meerkat</span> <span class="k">as</span> <span class="nn">mk</span>
    <span class="kn">from</span> <span class="nn">meerkat.columns.abstract</span> <span class="kn">import</span> <span class="n">column</span>

    <span class="kn">from</span> <span class="nn">.concat</span> <span class="kn">import</span> <span class="n">concat</span>

    <span class="k">if</span> <span class="n">use_ray</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ray</span>

        <span class="n">ray</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">ignore_reinit_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logging_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
        <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">set_progress_bars</span><span class="p">(</span><span class="n">enabled</span><span class="o">=</span><span class="n">pbar</span><span class="p">)</span>

        <span class="c1"># Step 1: Walk through the DeferredColumns and build a list of functions</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">DeferredColumn</span><span class="p">):</span>
            <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>

            <span class="c1"># For linear pipelines, there will be either one elem in args or one key in</span>
            <span class="c1"># kwargs</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple args not supported with `use_ray=True`.&quot;</span><span class="p">)</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Multiple kwargs not supported with `use_ray=True`.&quot;</span>
                    <span class="p">)</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">kwargs</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No args or kwargs.&quot;</span><span class="p">)</span>

        <span class="c1"># Step 2: Create the ray dataset from the base column</span>
        <span class="c1"># TODO (dean): test added_dim on other data types</span>
        <span class="n">added_dim</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">PandasScalarColumn</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="n">curr</span><span class="p">}))</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span>
            <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">ArrowScalarColumn</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">table</span><span class="p">({</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span><span class="p">}))</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span>
                <span class="n">num_blocks</span>
            <span class="p">)</span>
            <span class="n">fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">NumPyTensorColumn</span><span class="p">):</span>
            <span class="n">ndarrays</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">data</span>
            <span class="k">if</span> <span class="n">ndarrays</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">added_dim</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">ndarrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ndarrays</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">ndarrays</span><span class="p">)</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">TorchTensorColumn</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">from_torch</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">ObjectColumn</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">from_items</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mk</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Multiple outputs (fan-out) not supported with `use_ray=True`.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># TODO (dean): Support fan-out (would have to create multiple pipelines)</span>
            <span class="c1"># ds = ray.data.from_pandas(curr.data._repr_pandas_()[0])</span>
            <span class="c1"># fns.append(lambda row: row.values())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Base column is of unsupported type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span><span class="si">}</span><span class="s2"> with `use_ray=True`.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Step 3: Build the pipeline by walking backwards through fns</span>
        <span class="n">pipe</span><span class="p">:</span> <span class="n">ray</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DatasetPipeline</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">blocks_per_window</span><span class="o">=</span><span class="n">blocks_per_window</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">fns</span><span class="p">):</span>
            <span class="c1"># TODO (dean): if batch_size &gt; 1, then use map_batches</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

        <span class="c1"># Step 4: Collect the results</span>
        <span class="n">result_ds</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span>
            <span class="n">pipe</span><span class="o">.</span><span class="n">rewindow</span><span class="p">(</span><span class="n">blocks_per_window</span><span class="o">=</span><span class="n">num_blocks</span><span class="p">)</span><span class="o">.</span><span class="n">iter_datasets</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">_output_type</span> <span class="o">==</span> <span class="n">mk</span><span class="o">.</span><span class="n">NumPyTensorColumn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">to_numpy_refs</span><span class="p">():</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">added_dim</span> <span class="k">else</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">added_dim</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mk</span><span class="o">.</span><span class="n">NumPyTensorColumn</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">column</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">_output_type</span> <span class="o">==</span> <span class="n">mk</span><span class="o">.</span><span class="n">TorchTensorColumn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">to_torch</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partition</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">column</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">_output_type</span> <span class="o">==</span> <span class="n">mk</span><span class="o">.</span><span class="n">PandasScalarColumn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">to_pandas_refs</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">column</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">result</span><span class="p">)[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">_output_type</span> <span class="o">==</span> <span class="n">mk</span><span class="o">.</span><span class="n">ArrowScalarColumn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">to_arrow_refs</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">partition</span><span class="p">)[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">combine_chunks</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">column</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">concat_arrays</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">_output_type</span> <span class="o">==</span> <span class="n">mk</span><span class="o">.</span><span class="n">ObjectColumn</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">result_ds</span><span class="o">.</span><span class="n">iter_batches</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">column</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported output type </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">_output_type</span><span class="si">}</span><span class="s2"> with `use_ray=True`.&quot;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">batch_start</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">pbar</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span>
                    <span class="nb">slice</span><span class="p">(</span><span class="n">batch_start</span><span class="p">,</span> <span class="n">batch_start</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">materialize</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By The Meerkat Team<br/>
  
      &copy; Copyright 2023 Meerkat.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>